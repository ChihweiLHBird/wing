---
title: RFC Template
description: Template for creating a new RFC
---

# Tests

- **Author(s):**: @tsuf239
- **Submission Date**: {YYYY-MM-DD}
- **Stage**: draft
- **Stage Date**: 2024-01-30

This rfc lists a few features that improve test-writing in wing, and strengthen wing's test framework.

1. [scopes](#1-scopes)
2. [lifecycle hooks](#2-lifecycle-hooks)
3. [integration with external libs](#3-integration-with-external-libs)
4. [mocks](#4-mocks)
5. [spies](#5-spies)
6. [resource management optimization](#6-resource-management-optimization)

---

## 1. Scopes

### Design

Currently there is a single test scope:

```
test {

}
```

Each test run in separation, and the environment (the collection of resources available in the file) is duplicated per test. Since this is the only way available now, the user cannot re-use resources between tests. The test are running on parallel- one on each cloud.Function and each reports separately to the test runner.

#### Suggested:

We'll add another scope (and have two in total- outer scope, and inner scope) for the following structure:
//TODO: names

```js
// file/global scope - preflight code only. Resources initialized here will be duplicated across outerScopes.
let counter = new cloud.Counter();

outerScope "bucket tests" {
  /// preflight code only. Resources initialized here will be shared across innerScopes.
  let bucket = new cloud.Bucket();

  innerScope "bucket starts empty" {
    /// inflight code only
    counter.inc(); //  = 0
    expect.equals(bucket.list().length, 0);
  }

  innerScope "adding file to bucket" {
    /// inflight code only
    counter.inc(); //  = 1
    bucket.put("x","y");
    expect.equals(bucket.list().length, 1);
  }

  innerScope "adding another file to bucket" {
    /// inflight code only
    counter.inc(); //  = 2
    bucket.put("x","y");
    expect.equals(bucket.list().length, 2);
  }
}

outerScope "more tests" {
  innerScope "test" {
    // inflight code only
    counter.inc(); //  = 0
  }
}

```

innerScope must be inside of an outerScope and outerScope must include at least one innerScope (otherwise a compilation error is thrown).

Resources initialized in the global scope- are duplicated in each outerScope.
Resources initialized in outerScope- are shared between its innerScopes.
outerScopes are executed in parallel.
innerScopes contain only inflight tests- that run one after the other- in the order they are written at.

Nesting of outerScope inside of outerScopes, innerScopes inside innerScopes or outerScopes inside innerScopes is not allowed.

Both test scopes will be ignored when compiling and running the wing file, without the `isTestEnvironment` attribute set to `true`.

### Requirements

- Users scan decide what resources will be duplicated and what resources are shared between tests.
- The system is clear, intuitive, and well-named.

### Implementation

// TBD

## 2. Lifecycle Hooks

### Design

// TBD

A collection of 4 functions (beforeAll, beforeEach, afterAll, afterEach) allow the user to hook into the life cycle of tests to avoid repeating setup and teardown inflight code.
They apply to the current scope:
_global scope:_

- beforeEach, afterEach are called before or after each outerScope- before running the first innerScope, and after running the last one.
- beforeAll, afterAll are called before starting any of the innerScopes and after running them all.

_outerScope:_

- beforeEach, afterEach are called before or after each innerScope.
- beforeAll, afterAll are called before or after the first innerScope, or after the last- similarly to running beforeEach, afterEach on the global scope- but only for the selected outerScope.

_innerScope:_

- beforeEach, beforeAll, afterEach, afterAll are not allowed.

beforeEach, beforeAll, afterEach, afterAll includes only inflight code.

for example:

```js
let bucket = new cloud.Bucket();

beforeAll(inflight () => {
  bucket.put("x1", "y");
});

beforeEach(inflight () => {
  bucket.put("x2", "y");
});

afterEach(inflight () => {
  bucket.delete("x2");
});

afterAll(inflight () => {
  bucket.delete("x1");
});

outerScope "running tests" {
  let counter = new cloud.Counter();

  beforeAll(inflight () => {
    counter.inc(1, "all");
  });

  beforeEach(inflight () => {
    counter.inc(2, "each");
  });

  afterEach(inflight () => {
    counter.inc(1, "each");
  });

  afterAll(inflight () => {
    counter.reset("each");
    counter.reset("all");
  });

  innerScope "testing bucket and counter" {
    expect.equals(bucket.list().length(), 2);
    expect.equals(counter.peek("all"), 1);
  }

  innerScope "testing counter" {
    expect.equals(counter.peek("each"), 5);
    expect.equals(counter.peek("all"), 1);
  }

}

outerScope "running other tests" {
  innerScope "testing the bucket" {
      expect.equals(bucket.get("x1"), "y");
      expect.equals(bucket.get("x2"), "y");
  }
}
```

### Requirements

- users will have a convenient way to write and execute their setup and teardown code.

### Implementation

```
beforeAll(inflight (): void): void;

afterAll(inflight (): void): void;

beforeEach(inflight (): void): void;

afterEach(inflight (): void): void;

```

Those functions will be handled by the testRunner during a test run. In a case that it we'll be decided they'll be deployed as independent `cloud.Function`s an identifier will be exported to the test runner (like we do today with the `test` handler).

Lifecycle functions will be ignored when compiling and running the wing file, without the `isTestEnvironment` attribute set to `true`.

## 3. Integration with External Libs

[In this section we discuss about integration with external libs, and the behavior of any libraries that execute something on `wing test` command.
Like the checks lib- what happen if we have both tests and checks on the same test file? is it allowed? ]

### Design

// TBD

### Requirements

// TBD

### Implementation

// TBD

## 4. mocks

[In this section we discuss about mocks]

### Design

// TBD

### Requirements

// TBD

### Implementation

// TBD

## 5. spies

[In this section we discuss about ways to get extra information about classes and methods that were used in a test.]

### Design

// TBD

### Requirements

// TBD

### Implementation

// TBD

## 6. resource management optimization

[In this section we discuss about optimization of test running- how can we assure that running hundreds of innerScopes or outerScopes, will end in a reasonable time and use of resources.]

### Design

// TBD

### Requirements

// TBD

### Implementation

// TBD

---

### Why are we doing this?

Strengthen wing's testing framework.

### Why should we _not_ do this?

As more features will be added, the implementation might be less intuitive to users. Breaking changes might be added.

### What is the technical solution (design) of this feature?

// TBD

### Is this a breaking change?

Might be. depends on implementation.

### What alternative solutions did you consider?

// TBD

### What are the drawbacks of this solution?

// TBD

### What is the high-level project plan?

The implementation will be done one feature after the other- starting with [scopes](#1-scopes). We'll make sure the documentation is up-to-date and highly accessible. A dedicated tutorial and/or workshop will be published for each of the features.
